Extending Om via Derive Components
==================================

We leverage the excellent work on Om/React, but choose a set of
different conventions and add some functionality to the default Om
component.

1. The Derive Component

A derive component depends on a shared database reference and one or
more parameters generated by the parent.  Rather than passing down all
data in these parameters, the render methods uses derive methods of
the database and parameters to lookup the data it needs to render (the
database as a value is static - meaning the current value of the
database).  When the DB changes, the component is marked dirty via
'om/refresh!' and will be re-rendered on the next animation cycle,
calling the invalidated derivation function in turn.

We implement this via a RenderDerived function that components
call from their default render method with a binding context that
captures dynamic dependencies just like a derive method.  

2. Pure UI or Persistent UI state.

Local state is use for memoryless-UI interactions (tab states, form
state, etc.a)

If the UI is persistent the lifecycle methods ensure that a database
model with default parameters exists and uses that to store state.  

3. Actions

We eschew core.async for reasons of latency and the general hair of
setting up little go loops in all our components.  Instead we use
callbacks passed down via Om's shared state mechanism to communicate
with parents.  Lateral communication, if needed, requires a
collaborating parent to route messages (e.g. drag and drop).  We
provide some tools for setting up this interaction in Om.

4. Organization

Typically we generate a model file which contains any prismatic schema
data about the database for sanity checking and documentation
purposes.  We also implement some core derive methods to compute
common functions of the model and action methods to perform changes to
the model, create new models, etc.

A d-component is a file with the component creation function, the
RenderDerived method implementation and any component-specific derive
methods.  Controll components will also implement a set of action
handlers that call action methods on appropriate objects.

